<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hand: Box Grabber</title>
    
    <!-- MediaPipe Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <!-- Three.js (3D Engine) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #121212;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }

        /* 3D Canvas Container */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: radial-gradient(circle at center, #1a1a1a 0%, #000000 100%);
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #444;
            padding: 20px;
            border-radius: 12px;
            width: 280px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            pointer-events: none;
        }

        .label { color: #aaa; font-size: 11px; letter-spacing: 1px; margin-bottom: 4px;}
        .info { color: #fff; font-weight: bold; font-size: 18px; margin-bottom: 15px; }
        .highlight { color: #00e676; }
        .instruction { font-size: 14px; color: #ddd; line-height: 1.4; border-top: 1px solid #444; padding-top: 10px;}

        /* Camera Feed */
        #camera-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border: 2px solid #333;
            border-radius: 8px;
            overflow: hidden;
            z-index: 10;
            background: black;
            opacity: 0.8;
        }

        #camera-canvas {
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }

        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            background: rgba(0,0,0,0.9);
            padding: 20px 40px;
            border-radius: 30px;
            z-index: 100;
            border: 1px solid #00e676;
            color: #00e676;
            box-shadow: 0 0 20px rgba(0, 230, 118, 0.2);
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="loader">Loading AI Model...<br><small>Please Allow Camera Access</small></div>

    <div id="hud">
        <div class="label">SYSTEM STATUS</div>
        <div class="info" id="status-text">WAITING...</div>

        <div class="label">INTERACTION</div>
        <div class="info" id="interaction-text">IDLE</div>

        <div class="instruction">
            ü§è <strong>PINCH</strong> your Index & Thumb to grab a box.<br>
            ‚úã <strong>RELEASE</strong> to drop it.
        </div>
    </div>

    <!-- 3D Scene -->
    <div id="canvas-container"></div>

    <!-- Hidden Video & Visible Debug Canvas -->
    <video id="input_video" style="display:none;"></video>
    <div id="camera-container">
        <canvas id="camera-canvas"></canvas>
    </div>

    <script>
        // --- 1. THREE.JS SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x111111, 0.02);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 25;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Enable shadows for realism
        container.appendChild(renderer.domElement);

        // Lighting
        const ambLight = new THREE.AmbientLight(0x505050); 
        scene.add(ambLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);
        
        const pointLight = new THREE.PointLight(0x00e676, 0.8, 50);
        pointLight.position.set(0, 5, 10);
        scene.add(pointLight);

        // --- 2. CREATE HAND MODEL ---
        const jointMeshes = [];
        const boneMeshes = [];
        const handGroup = new THREE.Group();
        scene.add(handGroup);

        const jointMat = new THREE.MeshPhongMaterial({ color: 0x00ffff, emissive: 0x002255 });
        const boneMat = new THREE.MeshPhongMaterial({ color: 0x888888 });

        // Create 21 Joints
        for (let i = 0; i < 21; i++) {
            const geo = new THREE.SphereGeometry(0.3, 16, 16);
            const mesh = new THREE.Mesh(geo, jointMat);
            handGroup.add(mesh);
            jointMeshes.push(mesh);
        }

        // Bones Map
        const CONNECTIONS = [
            [0,1], [1,2], [2,3], [3,4],       
            [0,5], [5,6], [6,7], [7,8],       
            [0,9], [9,10], [10,11], [11,12],  
            [0,13], [13,14], [14,15], [15,16],
            [0,17], [17,18], [18,19], [19,20] 
        ];

        CONNECTIONS.forEach(() => {
            const geo = new THREE.CylinderGeometry(0.12, 0.12, 1, 8);
            const mesh = new THREE.Mesh(geo, boneMat);
            handGroup.add(mesh);
            boneMeshes.push(mesh);
        });

        // --- 3. CREATE INTERACTIVE BOXES ---
        const boxes = [];
        const boxGeometry = new THREE.BoxGeometry(2.5, 2.5, 2.5);
        
        // Colors for our 5 boxes
        const boxColors = [0xFF0000, 0xFFFF00, 0x00FF00, 0x00FFFF, 0xFF00FF];

        for(let i=0; i<5; i++){
            const mat = new THREE.MeshStandardMaterial({ 
                color: boxColors[i], 
                roughness: 0.2, 
                metalness: 0.5 
            });
            const box = new THREE.Mesh(boxGeometry, mat);
            
            // Random Position within reachable area
            box.position.x = (Math.random() - 0.5) * 15; // -7.5 to 7.5
            box.position.y = (Math.random() - 0.5) * 10; // -5 to 5
            box.position.z = (Math.random() - 0.5) * 5;  // -2.5 to 2.5
            
            // Add custom property to track if it's grabbed
            box.userData = { 
                id: i,
                originalColor: boxColors[i], 
                isGrabbed: false,
                velocity: new THREE.Vector3(0,0,0) // For simple float physics
            };

            scene.add(box);
            boxes.push(box);
        }

        // --- 4. GAME STATE ---
        let grabbedBox = null;
        let pinchCenter = new THREE.Vector3();
        let isPinching = false;
        const GRAB_THRESHOLD = 3.0; // Distance between fingers to count as "Pinch"
        const INTERACTION_DISTANCE = 3.5; // Distance from hand to box to allow grab

        // DOM Elements
        const statusText = document.getElementById('status-text');
        const interactText = document.getElementById('interaction-text');
        const loader = document.getElementById('loader');

        // --- 5. MEDIAPIPE LOGIC ---
        function onResults(results) {
            // Draw small debug view
            const ctx = document.getElementById('camera-canvas').getContext('2d');
            ctx.save();
            ctx.clearRect(0, 0, 160, 120);
            ctx.drawImage(results.image, 0, 0, 160, 120);
            ctx.restore();

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusText.innerText = "HAND DETECTED";
                statusText.className = "info highlight";
                
                const landmarks = results.multiHandLandmarks[0];
                update3DHand(landmarks);
                checkInteractions();
            } else {
                statusText.innerText = "NO HAND FOUND";
                statusText.className = "info";
                
                // If hand is lost, drop everything
                if(grabbedBox) releaseBox();
            }
        }

        // Update Hand Mesh Positions
        function update3DHand(landmarks) {
            const xMult = 25; const yMult = 20; const zMult = 25;
            const xOff = 12.5; const yOff = 10;

            // Update Joints
            landmarks.forEach((lm, index) => {
                const mesh = jointMeshes[index];
                mesh.position.x = (lm.x * -xMult) + xOff;
                mesh.position.y = (lm.y * -yMult) + yOff;
                mesh.position.z = lm.z * -zMult;
            });

            // Update Bones
            CONNECTIONS.forEach((pair, index) => {
                const bone = boneMeshes[index];
                const posA = jointMeshes[pair[0]].position;
                const posB = jointMeshes[pair[1]].position;

                bone.position.copy(posA).add(posB).multiplyScalar(0.5);
                bone.lookAt(posB);
                bone.rotateX(Math.PI / 2);
                bone.scale.set(1, posA.distanceTo(posB), 1);
            });

            // CALCULATE PINCH LOGIC
            // Index Finger Tip is #8, Thumb Tip is #4
            const indexTip = jointMeshes[8].position;
            const thumbTip = jointMeshes[4].position;

            // Midpoint between fingers (Where we hold the box)
            pinchCenter.copy(indexTip).add(thumbTip).multiplyScalar(0.5);

            // Distance between fingers
            const pinchDistance = indexTip.distanceTo(thumbTip);
            
            // Simple hysteresis for pinch stability
            if(isPinching) {
                // To release, fingers must open wide (hysteresis)
                if(pinchDistance > GRAB_THRESHOLD * 1.5) isPinching = false;
            } else {
                // To grab, fingers must be close
                if(pinchDistance < GRAB_THRESHOLD) isPinching = true;
            }
        }

        function checkInteractions() {
            if (grabbedBox) {
                // -- STATE: HOLDING BOX --
                interactText.innerText = "GRABBING BOX " + (grabbedBox.userData.id + 1);
                interactText.style.color = "#00e676"; // Green

                // Move box to hand
                grabbedBox.position.copy(pinchCenter);
                
                // Check release
                if (!isPinching) {
                    releaseBox();
                }

            } else {
                // -- STATE: IDLE / HOVERING --
                let closestBox = null;
                let minDist = Infinity;

                // Find closest box
                boxes.forEach(box => {
                    const dist = box.position.distanceTo(pinchCenter);
                    
                    // Reset color
                    box.material.emissive.setHex(0x000000);

                    if (dist < INTERACTION_DISTANCE) {
                        if (dist < minDist) {
                            minDist = dist;
                            closestBox = box;
                        }
                    }
                });

                if (closestBox) {
                    // Hover Effect
                    closestBox.material.emissive.setHex(0x555555); // Glow white-ish
                    interactText.innerText = "HOVERING...";
                    interactText.style.color = "#ffff00"; // Yellow

                    // Attempt Grab
                    if (isPinching) {
                        grabBox(closestBox);
                    }
                } else {
                    interactText.innerText = "IDLE";
                    interactText.style.color = "#fff";
                }
            }
        }

        function grabBox(box) {
            grabbedBox = box;
            box.userData.isGrabbed = true;
            // Highlight grabbed box
            box.material.color.setHex(0xFFFFFF); 
        }

        function releaseBox() {
            if(grabbedBox) {
                grabbedBox.userData.isGrabbed = false;
                grabbedBox.material.color.setHex(grabbedBox.userData.originalColor);
                grabbedBox = null;
            }
        }

        // --- 6. INITIALIZATION & LOOP ---
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const cam = new Camera(document.getElementById('input_video'), {
            onFrame: async () => await hands.send({image: document.getElementById('input_video')}),
            width: 320,
            height: 240
        });

        cam.start().then(() => loader.style.display = 'none');

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            // Add slight floating animation to idle boxes
            boxes.forEach(box => {
                if(!box.userData.isGrabbed) {
                    box.rotation.x += 0.01;
                    box.rotation.y += 0.01;
                }
            });

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
